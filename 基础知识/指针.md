# 指针类型和值

在Go中，一个无名指针类型的字面形式为T，其中T为一个任意类型。类型T称为指针类型T的基类型（base type）。 如果一个指针类型的基类型为T，则我们可以称此指针类型为一个T指针类型。

虽然我们可以声明具名指针类型，但是一般不推荐这么做，因为无名指针类型的可读性更高。

如果一个指针类型的底层类型是*T，则它的基类型为T。

如果两个无名指针类型的基类型为同一类型，则这两个无名指针类型亦为同一类型。

一些指针类型的例子：

```
*int  // 一个基类型为int的无名指针类型。
**int // 一个多级无名指针类型，它的基类型为int。

type Ptr *int // Ptr是一个具名指针类型，它的基类型为int。
type PP *Ptr  // PP是一个具名多级指针类型，它的基类型为Ptr。
```

指针类型的零值的字面量使用预声明的nil来表示。一个nil指针（常称为空指针）中不存储任何地址。

如果一个指针类型的基类型为T，则此指针类型的值只能存储类型为T的值的地址。

# 声明指针值

有两种方式来得到一个指针值：

```
1. 我们可以用内置函数new来为任何类型的值开辟一块内存并将此内存块的起始地址做为此值的地址返回。 假设T是任一类型，则函数调用 new(T)返回一个类型为*T的指针值。存储在返回指针值所表示的地址处的值（可被看作是一个匿名变量）为T的零值。

2.我们也可以使用前置取地址操作符&来获取一个可寻址的值的地址。对于一个类型为 T的可寻址的值t，我们可以用&t来取得它的地址。&t的类型为*T。
```

### 可寻址类型

* 变量
* 可寻址的结构体的字段
* 可寻址的数组的元素
* 任意切片的元素（无论是可寻址切片或不可寻址切片）
* 指针解引用（dereference）操作

### 不可寻址类型

* 字符串的字节元素
* 映射元素
* 接口值的动态值（类型断言的结果）
* 常量（包括具名常量和字面量）
* 声明的包级别函数
* 方法（用做函数值）
* 中间结果值
  * 函数调用
  * 显式值转换
  * 各种操作，不包含指针解引用（dereference）操作，但是包含：
    * 通道接收操作
    * 子字符串操作
    * 子切片操作
    * 加法、减法、乘法、以及除法等等。

```
请注意：&T{}在Go里是一个语法糖，它是 tmp := T{}; (&tmp)的简写形式。 所以 &T{}是合法的并不代表字面量T{}是可寻址的。
```

# 指针（地址）解引用

```
我们可以使用前置解引用操作符*来访问存储在一个指针所表示的地址处的值（即此指针所引用着的值）。 比如，对于基类型为T的指针类型的一个指针值p，我们可以用*p来表示地址p处的值。 此值的类型为T。*p称为指针p的解引用。解引用是取地址的逆过程。
```

解引用一个nil指针将产生一个[恐慌](https://gfw.go101.org/article/control-flows-more.html#panic-recover)。

# 允许

### 返回一个局部变量的地址

和C不一样，Go是支持垃圾回收的，所以一个函数返回其内声明的局部变量的地址是绝对安全的。比如：

```
func newInt() *int {
	a := 3
	return &a
}
```

# 限制

为了安全起见，Go指针在使用上相对于C指针有很多限制。 通过施加这些限制，Go指针保留了C指针的好处，同时也避免了C指针的危险性。

### 不支持算术运算

在Go中，指针是不能参与算术运算的。比如，对于一个指针 `p`， 运算 `p++`和 `p-2`都是非法的。

如果 `p`为一个指向一个数值类型值的指针，`*p++`将被编译器认为是合法的并且等价于 `(*p)++`。 换句话说，解引用操作符 `*`的优先级都高于自增 `++`和自减 `--`操作符。

# 陷阱

### for range 遍历

```
package main

import "fmt"

type Person struct {
	name string
}

func main() {
	arr := []Person{
		Person{"小明"},
		Person{"小刚"},
	}
	var res []*Person
	for _, v := range arr {
		fmt.Printf("v 指针 %p\n", &v)
		fmt.Println("v 的值", v)
		res = append(res, &v)
  	}
	fmt.Println(res)
	// 遍历查看结果集
	for _, person := range res{
		fmt.Println("name-->:", person.name)
	}
}
```

```
输出：
v 指针 0xc0001101e0
v 的值 {小明}
v 指针 0xc0001101e0
v 的值 {小刚}
[0xc0001101e0 0xc0001101e0]
name-->: 小刚
name-->: 小刚
```

可以看到在 res 中的指针是一样的，也就是说在 `for range` 的时候，**v 只初始化了一次** ，之后的遍历都是在原来遍历的基础上赋值，即，**v的指针（地址）并没有变，所指向的地址却跟随遍历变化**。遍历结束时，该指针指向的是最后一次遍历的v的值，所以最后 res 中就都成了最后遍历的v的值。

这里正确的做法是使用下标：

```
	for i, _ := range arr {
		fmt.Printf("v 指针 %p\n", &arr[i])
		fmt.Println("v 的值", arr[i])
		res = append(res, &arr[i])
	}
```

```
输出：
v 指针 0xc0000a6020
v 的值 {小明}
v 指针 0xc0000a6030
v 的值 {小刚}
[0xc0000a6020 0xc0000a6030]
name-->: 小明
name-->: 小刚
```
